From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrHua269 <wangxyper@163.com>
Date: Fri, 11 Aug 2023 22:40:40 +0800
Subject: [PATCH] Readd reload command and prepare for datapack command


diff --git a/src/main/java/ca/spottedleaf/concurrentutil/scheduler/SchedulerThreadPool.java b/src/main/java/ca/spottedleaf/concurrentutil/scheduler/SchedulerThreadPool.java
index 0ce825d7af2a1dbeac5c22640534ee1901edce20..3cc8eb80e03e5c076e69908a7cbf085aae205ac1 100644
--- a/src/main/java/ca/spottedleaf/concurrentutil/scheduler/SchedulerThreadPool.java
+++ b/src/main/java/ca/spottedleaf/concurrentutil/scheduler/SchedulerThreadPool.java
@@ -3,8 +3,10 @@ package ca.spottedleaf.concurrentutil.scheduler;
 import ca.spottedleaf.concurrentutil.util.ConcurrentUtil;
 import ca.spottedleaf.concurrentutil.util.TimeUtil;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.threadedregions.TickRegionScheduler;
 import io.papermc.paper.util.TraceUtil;
 import io.papermc.paper.util.set.LinkedSortedSet;
+import me.earthme.molia.threadedregioncontroller.RegionTickHolder;
 import org.slf4j.Logger;
 import java.lang.invoke.VarHandle;
 import java.util.BitSet;
@@ -490,11 +492,22 @@ public class SchedulerThreadPool {
                     return;
                 }
 
+                //Molia start - For data pack command
+                if (!RegionTickHolder.INSTANCE.shouldRunNextTick(((TickRegionScheduler.TickThreadRunner) this.thread))){
+                    RegionTickHolder.INSTANCE.onRegionRunnerIdle();//Molia - For data pack command
+                    while (!RegionTickHolder.INSTANCE.shouldRunNextTick((TickRegionScheduler.TickThreadRunner) this.thread)){
+                        LockSupport.parkNanos("IDLE",1_000_000);
+                    }
+                    RegionTickHolder.INSTANCE.onRegionBreakOutIdle(); //Molia - For data pack command
+                }
+                //Molia end
+
                 switch (startStateType) {
                     case STATE_IDLE: {
                         while (this.state.state == STATE_IDLE) {
                             LockSupport.park();
                             if (this.scheduler.halted) {
+                                RegionTickHolder.INSTANCE.onRegionRunnerDestroyed(((TickRegionScheduler.TickThreadRunner) this.thread)); //Molia - For data pack command
                                 return;
                             }
                         }
@@ -513,6 +526,7 @@ public class SchedulerThreadPool {
                             }
                             LockSupport.parkNanos(startState, diff);
                             if (this.scheduler.halted) {
+                                RegionTickHolder.INSTANCE.onRegionRunnerDestroyed(((TickRegionScheduler.TickThreadRunner) this.thread)); //Molia - For data pack command
                                 return;
                             }
                         }
@@ -521,11 +535,12 @@ public class SchedulerThreadPool {
                             continue main_state_loop;
                         }
 
+                        RegionTickHolder.INSTANCE.onRegionRunnerStartTicking(); //Molia - For data pack command
                         // TODO exception handling
                         final boolean reschedule = startStateTask.runTick();
 
                         this.returnTask(startStateTask, reschedule);
-
+                        RegionTickHolder.INSTANCE.onRegionRunnerFinishedCurrentTick(); //Molia - For data pack command
                         continue main_state_loop;
                     }
 
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
index f13c32b608cad9793619eb4dbac4f99daf690bba..d1c9dd1a9fad45230e0db7781f0549d1eff5d9a3 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
@@ -4,6 +4,7 @@ import ca.spottedleaf.concurrentutil.scheduler.SchedulerThreadPool;
 import ca.spottedleaf.concurrentutil.util.TimeUtil;
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.util.TickThread;
+import me.earthme.molia.threadedregioncontroller.RegionTickHolder;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.level.ChunkPos;
@@ -205,6 +206,7 @@ public final class TickRegionScheduler {
 
         public TickThreadRunner(final Runnable run, final String name) {
             super(run, name);
+            RegionTickHolder.INSTANCE.onRegionRunnerCreated(this); //Molia - For datapack command
         }
     }
 
diff --git a/src/main/java/me/earthme/molia/thread/CraftSchedulerRunner.java b/src/main/java/me/earthme/molia/thread/CraftSchedulerRunner.java
index 4f1ff25fb774e20c7e9c33368539072ebae6bc2e..ad28892c7f8cd1b0af1ce1774ce10e0cfdc33bfb 100644
--- a/src/main/java/me/earthme/molia/thread/CraftSchedulerRunner.java
+++ b/src/main/java/me/earthme/molia/thread/CraftSchedulerRunner.java
@@ -1,10 +1,15 @@
 package me.earthme.molia.thread;
 
 import io.papermc.paper.util.TickThread;
+import me.earthme.molia.threadedregioncontroller.RegionTickHolder;
 import net.minecraft.server.MinecraftServer;
 import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.CraftServer;
+import org.jetbrains.annotations.NotNull;
 
+import java.util.Deque;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.locks.LockSupport;
 
@@ -13,12 +18,13 @@ import java.util.concurrent.locks.LockSupport;
  * WARNING:USE THIS WOULD MAKE BUKKIT PLUGINS CAN CRASH YOUR SERVER
  */
 @Deprecated(forRemoval = true)
-public class CraftSchedulerRunner extends TickThread {
+public class CraftSchedulerRunner extends TickThread implements Executor {
     public static final CraftSchedulerRunner RUNNER_INSTANCE;
 
     private static final long fullCycle = TimeUnit.MILLISECONDS.toNanos(50);
     private long lastTimeOut = 0;
     private volatile int tickCount = 0;
+    private final Deque<Runnable> localTasks = new ConcurrentLinkedDeque<>();
 
     private CraftSchedulerRunner(){
         super();
@@ -60,6 +66,29 @@ public class CraftSchedulerRunner extends TickThread {
     }
 
     protected void doSchedulerTask(){
+        //Flush tasks
+        Runnable task;
+        while ((task = this.localTasks.poll()) != null){
+            try {
+                task.run();
+            }catch (Exception e){
+                e.printStackTrace();
+            }
+        }
+
+        //Do not run task when all tick actions are paused
+        if (!RegionTickHolder.INSTANCE.shouldRunNextTick(null)){
+            RegionTickHolder.INSTANCE.updateSchedulerRunnerStats(true);
+            return;
+        }
+
+        RegionTickHolder.INSTANCE.updateSchedulerRunnerStats(false);
+
         ((CraftServer) Bukkit.getServer()).getScheduler().mainThreadHeartbeat(this.tickCount++);
     }
+
+    @Override
+    public void execute(@NotNull Runnable command) {
+        this.localTasks.offer(command);
+    }
 }
diff --git a/src/main/java/me/earthme/molia/threadedregioncontroller/RegionTickHolder.java b/src/main/java/me/earthme/molia/threadedregioncontroller/RegionTickHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..949bbc9f764579c034a31a60143428caf0619266
--- /dev/null
+++ b/src/main/java/me/earthme/molia/threadedregioncontroller/RegionTickHolder.java
@@ -0,0 +1,115 @@
+package me.earthme.molia.threadedregioncontroller;
+
+import com.google.common.collect.Maps;
+import io.papermc.paper.threadedregions.TickRegionScheduler;
+import me.earthme.molia.thread.CraftSchedulerRunner;
+
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.LockSupport;
+import java.util.concurrent.locks.ReentrantLock;
+
+public class RegionTickHolder {
+    public static final RegionTickHolder INSTANCE = new RegionTickHolder();
+
+    private final AtomicInteger totalCreated = new AtomicInteger();
+    private final AtomicInteger totalTicking = new AtomicInteger();
+    private final AtomicInteger totalIdle = new AtomicInteger();
+    private final AtomicBoolean schedulerRunnerBlocked = new AtomicBoolean(false);
+    private boolean global_shouldRunNextTick = true;
+    private final Map<TickRegionScheduler.TickThreadRunner,Boolean> single_shouldRunNextTick = Maps.newConcurrentMap();
+    private final Lock accessLock = new ReentrantLock(true);
+
+
+    public void updateSchedulerRunnerStats(boolean blocked){
+        this.schedulerRunnerBlocked.set(blocked);
+    }
+
+    public void releaseAllTickRunners(){
+        this.accessLock.lock();
+        try {
+            this.global_shouldRunNextTick = true;
+        }finally {
+            this.accessLock.unlock();
+        }
+    }
+
+    public void awaitAllTickRunnerIdle(){
+        for(;;){
+            if (this.totalTicking.get() == 0 && this.schedulerRunnerBlocked.get()){
+                this.accessLock.lock();
+                try {
+                    if (this.totalIdle.get() == this.single_shouldRunNextTick.size()){
+                        break;
+                    }
+                }finally {
+                    this.accessLock.unlock();
+                }
+            }
+
+            LockSupport.parkNanos(1_000_000L);
+        }
+    }
+
+    public void blockAllTickRunners(){
+        this.accessLock.lock();
+        try {
+            this.global_shouldRunNextTick = false;
+        }finally {
+            this.accessLock.unlock();
+        }
+    }
+
+    public void onRegionBreakOutIdle(){
+        this.totalIdle.getAndDecrement();
+    }
+
+    public void onRegionRunnerIdle(){
+        this.totalIdle.getAndIncrement();
+    }
+
+    public void onRegionRunnerFinishedCurrentTick(){
+        this.totalTicking.getAndDecrement();
+    }
+
+    public void onRegionRunnerStartTicking(){
+        this.totalTicking.getAndIncrement();
+    }
+
+    public void onRegionRunnerCreated(TickRegionScheduler.TickThreadRunner worker){
+        this.accessLock.lock();
+        try {
+            if (!this.global_shouldRunNextTick){
+                this.single_shouldRunNextTick.putIfAbsent(worker,false);
+            }
+
+            this.single_shouldRunNextTick.putIfAbsent(worker,true);
+        }finally {
+            this.accessLock.unlock();
+        }
+        this.totalCreated.getAndIncrement();
+    }
+
+    public void onRegionRunnerDestroyed(TickRegionScheduler.TickThreadRunner worker){
+        this.accessLock.lock();
+        try {
+            this.single_shouldRunNextTick.remove(worker);
+        }finally {
+            this.accessLock.unlock();
+        }
+    }
+
+    public boolean shouldRunNextTick(TickRegionScheduler.TickThreadRunner worker){
+        this.accessLock.lock();
+        try {
+            if (CraftSchedulerRunner.isRunnerThread()){
+                return this.global_shouldRunNextTick;
+            }
+            return this.global_shouldRunNextTick && this.single_shouldRunNextTick.get(worker) || !this.schedulerRunnerBlocked.get();
+        }finally {
+            this.accessLock.unlock();
+        }
+    }
+}
diff --git a/src/main/java/net/minecraft/commands/Commands.java b/src/main/java/net/minecraft/commands/Commands.java
index 44576310cc5b89c287b0ab7ba1a99d76b67f33dd..81ae9b32cb81375ae89c05df02ae798bf1430b36 100644
--- a/src/main/java/net/minecraft/commands/Commands.java
+++ b/src/main/java/net/minecraft/commands/Commands.java
@@ -149,7 +149,7 @@ public class Commands {
         //CloneCommands.register(this.dispatcher, commandRegistryAccess); // Folia - region threading - TODO
         DamageCommand.register(this.dispatcher, commandRegistryAccess);
         DataCommands.register(this.dispatcher); // Folia - region threading - TODO // Kaiiju
-        //DataPackCommand.register(this.dispatcher); // Folia - region threading - TODO
+        DataPackCommand.register(this.dispatcher); // Folia - region threading - TODO //Molia - Renable data pack command
         //DebugCommand.register(this.dispatcher); // Folia - region threading - TODO
         DefaultGameModeCommands.register(this.dispatcher);
         DifficultyCommand.register(this.dispatcher);
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index a8379ad2e0eb8ace95239e8826b414d0b0df1d1c..9a425c0cc7a2f9a4434990fd68f1d8c9f1387134 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -46,6 +46,7 @@ import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.Executor;
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
 import java.util.function.Consumer;
 import java.util.function.Function;
@@ -162,7 +163,7 @@ import net.minecraft.world.level.storage.ServerLevelData;
 import net.minecraft.world.level.storage.WorldData;
 import net.minecraft.world.level.storage.loot.LootDataManager;
 import org.slf4j.Logger;
-
+import me.earthme.molia.threadedregioncontroller.RegionTickHolder;
 // CraftBukkit start
 import com.mojang.datafixers.util.Pair;
 import com.mojang.serialization.DynamicOps;
@@ -2183,13 +2184,16 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public CompletableFuture<Void> reloadResources(Collection<String> dataPacks, io.papermc.paper.event.server.ServerResourcesReloadedEvent.Cause cause) {
         // Paper end
         RegistryAccess.Frozen iregistrycustom_dimension = this.registries.getAccessForLoading(RegistryLayer.RELOADABLE);
-        CompletableFuture<Void> completablefuture = CompletableFuture.supplyAsync(() -> {
+        CompletableFuture<Void> completablefuture = CompletableFuture.runAsync(() -> {
+            RegionTickHolder.INSTANCE.blockAllTickRunners(); //Molia - For data pack command
+            RegionTickHolder.INSTANCE.awaitAllTickRunnerIdle();
+        }).thenApplyAsync((nullValue) -> {
             Stream<String> stream = dataPacks.stream(); // CraftBukkit - decompile error
             PackRepository resourcepackrepository = this.packRepository;
 
             Objects.requireNonNull(this.packRepository);
             return stream.<Pack>map(resourcepackrepository::getPack).filter(Objects::nonNull).map(Pack::open).collect(ImmutableList.toImmutableList()); // CraftBukkit - decompile error // Paper - decompile error // todo: is this needed anymore?
-        }, this).thenCompose((immutablelist) -> {
+        }, CraftSchedulerRunner.RUNNER_INSTANCE).thenCompose((immutablelist) -> {
             MultiPackResourceManager resourcemanager = new MultiPackResourceManager(PackType.SERVER_DATA, immutablelist);
 
             return ReloadableServerResources.loadResources(resourcemanager, iregistrycustom_dimension, this.worldData.enabledFeatures(), this.isDedicatedServer() ? Commands.CommandSelection.DEDICATED : Commands.CommandSelection.INTEGRATED, this.getFunctionCompilationLevel(), this.executor, this).whenComplete((datapackresources, throwable) -> {
@@ -2211,9 +2215,6 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.resources.managers.updateRegistryTags(this.registryAccess());
             net.minecraft.world.item.alchemy.PotionBrewing.reload(); // Paper
             // Paper start
-            if (Thread.currentThread() != this.serverThread) {
-                return;
-            }
             // this.getPlayerList().saveAll(); // Paper - we don't need to save everything, just advancements
             for (ServerPlayer player : this.getPlayerList().getPlayers()) {
                 player.getAdvancements().save();
@@ -2224,12 +2225,9 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             this.structureTemplateManager.onResourceManagerReload(this.resources.resourceManager);
             org.bukkit.craftbukkit.block.data.CraftBlockData.reloadCache(); // Paper - cache block data strings, they can be defined by datapacks so refresh it here
             new io.papermc.paper.event.server.ServerResourcesReloadedEvent(cause).callEvent(); // Paper - fire after everything has been reloaded
-        }, this);
-
-        if (this.isSameThread()) {
-            Objects.requireNonNull(completablefuture);
-            this.managedBlock(completablefuture::isDone);
-        }
+        }, CraftSchedulerRunner.RUNNER_INSTANCE).whenComplete((nullValue, exception) -> {
+            RegionTickHolder.INSTANCE.releaseAllTickRunners();
+        });
 
         return completablefuture;
     }
diff --git a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
index 83701fbfaa56a232593ee8f11a3afb8941238bfa..5815afa3a85e23b25aa04acb5ac61bc39892b658 100644
--- a/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
+++ b/src/main/java/net/minecraft/util/thread/BlockableEventLoop.java
@@ -10,6 +10,8 @@ import java.util.concurrent.Executor;
 import java.util.concurrent.locks.LockSupport;
 import java.util.function.BooleanSupplier;
 import java.util.function.Supplier;
+
+import io.papermc.paper.util.TickThread;
 import net.minecraft.util.profiling.metrics.MetricCategory;
 import net.minecraft.util.profiling.metrics.MetricSampler;
 import net.minecraft.util.profiling.metrics.MetricsRegistry;
@@ -71,7 +73,7 @@ public abstract class BlockableEventLoop<R extends Runnable> implements Profiler
     }
 
     public void executeBlocking(Runnable runnable) {
-        if (!this.isSameThread()) {
+        if (!this.isSameThread() && !TickThread.isTickThread()) { //Molia - for data pack command
             this.submitAsync(runnable).join();
         } else {
             runnable.run();
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
index c057c2942b3b9c33c03051e30f3196fcac99d331..8a3f9edf50bbd26f0afd619d5755263706349b06 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
@@ -107,8 +107,9 @@ public class CraftScheduler implements BukkitScheduler {
         }
     };
     private CraftAsyncDebugger debugTail = this.debugHead;
-
     */ // Paper end
+    //Molia start - For datapack command
+
     private static final int RECENT_TICKS;
 
     static {
