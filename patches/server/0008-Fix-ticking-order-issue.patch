From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: wangxyper <wangxyper@163.com>
Date: Thu, 24 Aug 2023 17:42:41 +0800
Subject: [PATCH] Fix ticking order issue


diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
index f821a6f64e21aa6cb7f237eaf5ff6a447c878453..e12061cc0eafe3823edae26b67550e8ada905ff5 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -289,8 +289,8 @@ public final class RegionizedWorldData {
     // entities
     private final List<ServerPlayer> localPlayers = Lists.newCopyOnWriteArrayList();
     private final ReferenceList<Entity> allEntities = new ReferenceList<>();
-    private final Set<Entity> entityTickList = Sets.newConcurrentHashSet();//ObjectSets.synchronize(new ObjectLinkedOpenHashSet<>());
-    private final Set<Mob> navigatingMobs = Sets.newConcurrentHashSet();
+    private final IteratorSafeOrderedReferenceSet<Entity> entityTickList = new IteratorSafeOrderedReferenceSet<>();//Sets.newConcurrentHashSet();//ObjectSets.synchronize(new ObjectLinkedOpenHashSet<>());
+    private final IteratorSafeOrderedReferenceSet<Mob> navigatingMobs = new IteratorSafeOrderedReferenceSet<>();
     public final dev.kaiijumc.kaiiju.KaiijuEntityThrottler entityThrottler = new dev.kaiijumc.kaiiju.KaiijuEntityThrottler(); // Kaiiju
 
     // block ticking
@@ -299,8 +299,8 @@ public final class RegionizedWorldData {
     private final LevelTicks<Fluid> fluidLevelTicks;
 
     // tile entity ticking
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newCopyOnWriteArrayList();
-    private final List<TickingBlockEntity> blockEntityTickers = Lists.newCopyOnWriteArrayList();
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = Collections.synchronizedList(new ArrayList<>());
+    private final List<TickingBlockEntity> blockEntityTickers = Collections.synchronizedList(new ArrayList<>());
     private boolean tickingBlockEntities;
 
     // time
@@ -533,9 +533,13 @@ public final class RegionizedWorldData {
     }
 
     public void forEachTickingEntity(final Consumer<Entity> action) {
-        final Iterator<Entity> iterator = this.entityTickList.iterator();
-        while (iterator.hasNext()) {
-            action.accept(iterator.next());
+        final IteratorSafeOrderedReferenceSet.Iterator<Entity> iterator = this.entityTickList.iterator();
+        try {
+            while (iterator.hasNext()) {
+                action.accept(iterator.next());
+            }
+        } finally {
+            iterator.finishedIterating();
         }
     }
 
@@ -581,8 +585,8 @@ public final class RegionizedWorldData {
         this.navigatingMobs.remove(mob);
     }
 
-    public Iterator<Mob> getNavigatingMobs() {
-        return this.navigatingMobs.iterator();
+    public IteratorSafeOrderedReferenceSet<Mob> getNavigatingMobs() {
+        return this.navigatingMobs;
     }
 
     // block ticking hooks
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 6c292eef5ea83887954785c78138e524526b31db..109c13ebe022c303bec709fe04fad90f3c80d584 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -6,6 +6,7 @@ import com.google.common.collect.Lists;
 import com.mojang.datafixers.DataFixer;
 import com.mojang.datafixers.util.Pair;
 import com.mojang.logging.LogUtils;
+import io.papermc.paper.util.maplist.IteratorSafeOrderedReferenceSet;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.longs.LongSet;
@@ -1894,25 +1895,30 @@ public class ServerLevel extends Level implements WorldGenLevel {
 
         if (Shapes.joinIsNotEmpty(voxelshape, voxelshape1, BooleanOp.NOT_SAME)) {
             List<PathNavigation> list = new ObjectArrayList();
-            Iterator iterator = Level.WORLD_DATA_POOL.getDataAnyThread(this,pos).getNavigatingMobs(); // Folia - region threading
+            final IteratorSafeOrderedReferenceSet<Mob> navigationMobs = Level.WORLD_DATA_POOL.getDataAnyThread(this,pos).getNavigatingMobs();
 
-            while (iterator.hasNext()) {
-                // CraftBukkit start - fix SPIGOT-6362
-                Mob entityinsentient;
-                try {
-                    entityinsentient = (Mob) iterator.next();
-                } catch (java.util.ConcurrentModificationException ex) {
-                    // This can happen because the pathfinder update below may trigger a chunk load, which in turn may cause more navigators to register
-                    // In this case we just run the update again across all the iterators as the chunk will then be loaded
-                    // As this is a relative edge case it is much faster than copying navigators (on either read or write)
-                    this.sendBlockUpdated(pos, oldState, newState, flags);
-                    return;
-                }
-                // CraftBukkit end
-                PathNavigation navigationabstract = entityinsentient.getNavigation();
+            Iterator iterator;
+            synchronized (navigationMobs){
+                iterator = navigationMobs.iterator(); // Folia - region threading
 
-                if (navigationabstract.shouldRecomputePath(pos)) {
-                    list.add(navigationabstract);
+                while (iterator.hasNext()) {
+                    // CraftBukkit start - fix SPIGOT-6362
+                    Mob entityinsentient;
+                    try {
+                        entityinsentient = (Mob) iterator.next();
+                    } catch (java.util.ConcurrentModificationException ex) {
+                        // This can happen because the pathfinder update below may trigger a chunk load, which in turn may cause more navigators to register
+                        // In this case we just run the update again across all the iterators as the chunk will then be loaded
+                        // As this is a relative edge case it is much faster than copying navigators (on either read or write)
+                        this.sendBlockUpdated(pos, oldState, newState, flags);
+                        return;
+                    }
+                    // CraftBukkit end
+                    PathNavigation navigationabstract = entityinsentient.getNavigation();
+
+                    if (navigationabstract.shouldRecomputePath(pos)) {
+                        list.add(navigationabstract);
+                    }
                 }
             }
 
diff --git a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
index 87d08f4d5bdec0ef96c0e4a91a2f595d2b0f0026..05ab3b42bf42ac4a5dddedc3acee29ac9c6e848d 100644
--- a/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/FallingBlockEntity.java
@@ -244,6 +244,8 @@ public class FallingBlockEntity extends Entity {
                                     this.spawnAtLocation((ItemLike) block);
                                 }
                             } else {
+                                System.out.println("F1 + "+flag1 +" F2 " + flag2 + " F3 "+flag3);
+                                System.out.println(this.level().getBlockState(blockposition.below()).getBlock().getName());
                                 this.discard();
                                 if (this.dropItem && this.level().getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
                                     this.callOnBrokenAfterFall(block, blockposition);
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index fd0009c7e94e063d6b5ce093faafea0d850e3796..2e7fcb803ef18a18180b8e09fc0d88818c3fa8e1 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -1013,28 +1013,30 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         int tilesThisCycle = 0;
         var toRemove = new it.unimi.dsi.fastutil.objects.ObjectOpenCustomHashSet<TickingBlockEntity>(net.minecraft.Util.identityStrategy()); // Paper - use removeAll
         toRemove.add(null);
-        for (int i = 0; i < blockEntityTickers.size(); i++) { // Paper - Disable tick limiters // Folia - regionised ticking
-            TickingBlockEntity tickingblockentity = (TickingBlockEntity) blockEntityTickers.get(i); // Folia - regionised ticking
-            // Spigot start
-            if (tickingblockentity == null) {
-                this.getCraftServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
-                tilesThisCycle--;
-                continue;
-            }
-            // Spigot end
-
-            if (tickingblockentity.isRemoved()) {
+        synchronized (blockEntityTickers){
+            for (int i = 0; i < blockEntityTickers.size(); i++) { // Paper - Disable tick limiters // Folia - regionised ticking
+                TickingBlockEntity tickingblockentity = (TickingBlockEntity) blockEntityTickers.get(i); // Folia - regionised ticking
                 // Spigot start
-                tilesThisCycle--;
-                toRemove.add(tickingblockentity); // Paper - use removeAll
+                if (tickingblockentity == null) {
+                    this.getCraftServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
+                    tilesThisCycle--;
+                    continue;
+                }
                 // Spigot end
-            } else if (this.shouldTickBlocksAt(tickingblockentity.getPos())) {
-                tickingblockentity.tick();
-                // Paper start - execute chunk tasks during tick
-                if ((i & 7) == 0) { // Folia - regionised ticking
-                    MinecraftServer.getServer().executeMidTickTasks();
+
+                if (tickingblockentity.isRemoved()) {
+                    // Spigot start
+                    tilesThisCycle--;
+                    toRemove.add(tickingblockentity); // Paper - use removeAll
+                    // Spigot end
+                } else if (this.shouldTickBlocksAt(tickingblockentity.getPos())) {
+                    tickingblockentity.tick();
+                    // Paper start - execute chunk tasks during tick
+                    if ((i & 7) == 0) { // Folia - regionised ticking
+                        MinecraftServer.getServer().executeMidTickTasks();
+                    }
+                    // Paper end - execute chunk tasks during tick
                 }
-                // Paper end - execute chunk tasks during tick
             }
         }
         blockEntityTickers.removeAll(toRemove); // Folia - regionised ticking
