From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: M2ke4U <79621885+MrHua269@users.noreply.github.com>
Date: Sun, 12 Nov 2023 20:26:48 +0800
Subject: [PATCH] Try fixing some memoryleaking issue


diff --git a/src/main/java/io/papermc/paper/chunk/system/ChunkSystem.java b/src/main/java/io/papermc/paper/chunk/system/ChunkSystem.java
index 64ab1e1e24ffbea37ca65a4fc7c1d6d4f49c0848..8f2808e56e03d18614d77031110260c5f02e3744 100644
--- a/src/main/java/io/papermc/paper/chunk/system/ChunkSystem.java
+++ b/src/main/java/io/papermc/paper/chunk/system/ChunkSystem.java
@@ -111,31 +111,31 @@ public final class ChunkSystem {
     public static void onChunkBorder(final LevelChunk chunk, final ChunkHolder holder) {
         chunk.playerChunk = holder;
         chunk.chunkStatus = net.minecraft.server.level.FullChunkStatus.FULL;
-        Level.WORLD_DATA_POOL.getDataAnyThread(chunk.level,chunk.locX,chunk.locZ).addChunk(chunk); // Folia - region threading
+        chunk.level.getCurrentWorldData().addChunk(chunk); // Folia - region threading
     }
 
     public static void onChunkNotBorder(final LevelChunk chunk, final ChunkHolder holder) {
         chunk.chunkStatus = net.minecraft.server.level.FullChunkStatus.INACCESSIBLE;
-        Level.WORLD_DATA_POOL.getDataAnyThread(chunk.level,chunk.locX,chunk.locZ).removeChunk(chunk); // Folia - region threading
+        chunk.level.getCurrentWorldData().removeChunk(chunk); // Folia - region threading
     }
 
     public static void onChunkTicking(final LevelChunk chunk, final ChunkHolder holder) {
-        Level.WORLD_DATA_POOL.getDataAnyThread(chunk.level,chunk.locX,chunk.locZ).addTickingChunk(chunk); // Folia - region threading
+        chunk.level.getCurrentWorldData().addTickingChunk(chunk); // Folia - region threading
         chunk.chunkStatus = net.minecraft.server.level.FullChunkStatus.BLOCK_TICKING;
     }
 
     public static void onChunkNotTicking(final LevelChunk chunk, final ChunkHolder holder) {
-        Level.WORLD_DATA_POOL.getDataAnyThread(chunk.level,chunk.locX,chunk.locZ).removeTickingChunk(chunk); // Folia - region threading
+        chunk.level.getCurrentWorldData().removeTickingChunk(chunk); // Folia - region threading
         chunk.chunkStatus = net.minecraft.server.level.FullChunkStatus.FULL;
     }
 
     public static void onChunkEntityTicking(final LevelChunk chunk, final ChunkHolder holder) {
-        Level.WORLD_DATA_POOL.getDataAnyThread(chunk.level,chunk.locX,chunk.locZ).addEntityTickingChunk(chunk); // Folia - region threading
+        chunk.level.getCurrentWorldData().addEntityTickingChunk(chunk); // Folia - region threading
         chunk.chunkStatus = net.minecraft.server.level.FullChunkStatus.ENTITY_TICKING;
     }
 
     public static void onChunkNotEntityTicking(final LevelChunk chunk, final ChunkHolder holder) {
-        Level.WORLD_DATA_POOL.getDataAnyThread(chunk.level,chunk.locX,chunk.locZ).removeEntityTickingChunk(chunk); // Folia - region threading
+        chunk.level.getCurrentWorldData().removeEntityTickingChunk(chunk); // Folia - region threading
         chunk.chunkStatus = net.minecraft.server.level.FullChunkStatus.BLOCK_TICKING;
     }
 
diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedData.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedData.java
index 5fe2b5cbb7410dfb12f10ead6f21437269b82c6c..4a0ac6acf90f24939656d4a68cef61fa95d7b0c8 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedData.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedData.java
@@ -154,13 +154,8 @@ public final class RegionizedData<T> {
             throw new IllegalStateException("World check failed: expected world: " + this.world.getWorld().getKey() + ", region world: " + region.getData().world.getWorld().getKey());
         }
 
-        final T ret = region.getData().getOrCreateRegionizedData(this);
 
-        if (ret instanceof RegionizedWorldData data){
-            Level.WORLD_DATA_POOL.updateRegion(region,data);
-        }
-
-        return ret;
+        return region.getData().getOrCreateRegionizedData(this);
     }
 
     /**
diff --git a/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java b/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java
index 1a787bd32f6408287ff3e14dd3dea7a65f72ab20..30875f66d52dd9d16ed0a7af41741b19ba40aa69 100644
--- a/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java
+++ b/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java
@@ -158,7 +158,6 @@ public final class ThreadedRegionizer<R extends ThreadedRegionizer.ThreadedRegio
 
     private void onRegionCreate(final ThreadedRegion<R, S> region) {
         final ThreadedRegion<R, S> conflict;
-        Level.WORLD_DATA_POOL.add(region);
         if ((conflict = this.regionsById.putIfAbsent(region.id, region)) != null) {
             throw new IllegalStateException("Region " + region + " is already mapped to " + conflict);
         }
@@ -166,7 +165,6 @@ public final class ThreadedRegionizer<R extends ThreadedRegionizer.ThreadedRegio
 
     private void onRegionDestroy(final ThreadedRegion<R, S> region) {
         final ThreadedRegion<R, S> removed = this.regionsById.remove(region.id);
-        Level.WORLD_DATA_POOL.drop(removed);
         if (removed != region) {
             throw new IllegalStateException("Expected to remove " + region + ", but removed " + removed);
         }
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
index d024827753e8d68badaa0b2323d2e1ccb44f5a5d..ba768596ec42baa008dc0136ea1cbabb53d46528 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
@@ -108,8 +108,6 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
         scheduler.descheduleRegion(data.tickHandle);
         // old handle cannot be scheduled anymore, copy to a new handle
         data.tickHandle = data.tickHandle.copy();
-
-        Level.WORLD_DATA_POOL.drop(region);
     }
 
     @Override
@@ -214,7 +212,7 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
         public final ServerLevel world;
 
         // generic regionised data
-        private final Reference2ReferenceOpenHashMap<RegionizedData<?>, Object> regionizedData = new Reference2ReferenceOpenHashMap<>();
+        private final Reference2ReferenceMap<RegionizedData<?>, Object> regionizedData = new Reference2ReferenceOpenHashMap<>();
 
         // tick data
         private ConcreteRegionTickHandle tickHandle = new ConcreteRegionTickHandle(this, SchedulerThreadPool.DEADLINE_NOT_SET);
@@ -259,7 +257,7 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             return this.holderManagerRegionData;
         }
 
-        <T> T getRegionizedData(final RegionizedData<T> regionizedData) {
+        public <T> T getRegionizedData(final RegionizedData<T> regionizedData) {
             return (T)this.regionizedData.get(regionizedData);
         }
 
@@ -291,7 +289,7 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             }
 
             // generic regionised data
-            for (final Iterator<Reference2ReferenceMap.Entry<RegionizedData<?>, Object>> dataIterator = this.regionizedData.reference2ReferenceEntrySet().fastIterator();
+            for (final Iterator<Reference2ReferenceMap.Entry<RegionizedData<?>, Object>> dataIterator = this.regionizedData.reference2ReferenceEntrySet().iterator();
                  dataIterator.hasNext();) {
                 final Reference2ReferenceMap.Entry<RegionizedData<?>, Object> regionDataEntry = dataIterator.next();
                 final RegionizedData<?> data = regionDataEntry.getKey();
@@ -358,7 +356,7 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
 
             // generic regionised data
             final long fromTickOffset = currentTickTo - currentTickFrom; // see merge jd
-            for (final Iterator<Reference2ReferenceMap.Entry<RegionizedData<?>, Object>> iterator = this.regionizedData.reference2ReferenceEntrySet().fastIterator(); iterator.hasNext();) {
+            for (final Iterator<Reference2ReferenceMap.Entry<RegionizedData<?>, Object>> iterator = this.regionizedData.reference2ReferenceEntrySet().iterator(); iterator.hasNext();) {
                 final Reference2ReferenceMap.Entry<RegionizedData<?>, Object> entry = iterator.next();
                 final RegionizedData<?> regionizedData = entry.getKey();
                 final Object from = entry.getValue();
diff --git a/src/main/java/me/earthme/molia/pool/WorldDataPool.java b/src/main/java/me/earthme/molia/pool/WorldDataPool.java
index 8e9d67dc9511400990153bbad6f169bce7ee6d67..afce0b58bad6cf7aef95854c84cc4f783b67321c 100644
--- a/src/main/java/me/earthme/molia/pool/WorldDataPool.java
+++ b/src/main/java/me/earthme/molia/pool/WorldDataPool.java
@@ -1,6 +1,7 @@
 package me.earthme.molia.pool;
 
 import com.google.common.collect.Maps;
+import io.papermc.paper.threadedregions.RegionizedData;
 import io.papermc.paper.threadedregions.RegionizedWorldData;
 import io.papermc.paper.threadedregions.ThreadedRegionizer;
 import io.papermc.paper.threadedregions.TickRegions;
@@ -20,44 +21,6 @@ import java.util.concurrent.locks.ReadWriteLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 public class WorldDataPool {
-    private final Map<Long,RegionizedWorldData> regionizedWorldDataMap = Maps.newHashMap();
-    private final ReadWriteLock accessLock = new ReentrantReadWriteLock();
-
-    public void add(ThreadedRegionizer.ThreadedRegion<?,?> region){
-        this.accessLock.writeLock().lock();
-        try {
-            if (this.regionizedWorldDataMap.containsKey(region.id)){
-                return;
-            }
-
-            this.regionizedWorldDataMap.put(region.id,null);
-        }finally {
-            this.accessLock.writeLock().unlock();
-        }
-    }
-
-    public void updateRegion(ThreadedRegionizer.ThreadedRegion<?,?> region, RegionizedWorldData data){
-        this.accessLock.writeLock().lock();
-        try {
-            if (!this.regionizedWorldDataMap.containsKey(region.id)){
-                return;
-            }
-
-            this.regionizedWorldDataMap.replace(region.id,data);
-        }finally {
-            this.accessLock.writeLock().unlock();
-        }
-    }
-
-    public void drop(ThreadedRegionizer.ThreadedRegion<?,?> region){
-        this.accessLock.writeLock().lock();
-        try {
-            this.regionizedWorldDataMap.remove(region.id);
-        }finally {
-            this.accessLock.writeLock().unlock();
-        }
-    }
-
     public RegionizedWorldData getDataAnyThread(Entity ent){
         final RegionizedWorldData got = ent.level().getCurrentWorldData();
         return got == null || !TickThread.isTickThreadFor(ent) ? getDataOffTickThread(ent) : got; //Skip it if we got the current world data
@@ -87,14 +50,7 @@ public class WorldDataPool {
 
         ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> target = ((ServerLevel) entity.level()).regioniser.getRegionAtUnsynchronised(entity.sectionX,entity.sectionZ);
 
-        this.accessLock.readLock().lock();
-        try {
-            ret = this.regionizedWorldDataMap.get(target.id);
-        }finally {
-            this.accessLock.readLock().unlock();
-        }
-
-        if (ret != null){
+        if ((ret = target.getData().getRegionizedData(target.regioniser.world.worldRegionData)) != null){
             return ret;
         }
 
@@ -106,14 +62,7 @@ public class WorldDataPool {
         ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> target = level.regioniser.getRegionAtUnsynchronised(chunkX,chunkZ);
         RegionizedWorldData ret;
 
-        this.accessLock.readLock().lock();
-        try {
-            ret = this.regionizedWorldDataMap.get(target.id);
-        }finally {
-            this.accessLock.readLock().unlock();
-        }
-
-        if (ret != null){
+        if ((ret = target.getData().getRegionizedData(target.regioniser.world.worldRegionData)) != null){
             return ret;
         }
 
