From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrHua269 <wangxyper@163.com>
Date: Sat, 12 Aug 2023 14:40:58 +0800
Subject: [PATCH] Fix patch issue & craft scheduler runner


diff --git a/src/main/java/io/papermc/paper/util/TickThread.java b/src/main/java/io/papermc/paper/util/TickThread.java
index a7fc98fb5365b3d0422415aa83f4ca9b9ed21f24..f7adf2dfd92c01168ea0846b4586ec38484aa5f6 100644
--- a/src/main/java/io/papermc/paper/util/TickThread.java
+++ b/src/main/java/io/papermc/paper/util/TickThread.java
@@ -6,6 +6,7 @@ import io.papermc.paper.threadedregions.RegionizedWorldData;
 import io.papermc.paper.threadedregions.ThreadedRegionizer;
 import io.papermc.paper.threadedregions.TickRegionScheduler;
 import io.papermc.paper.threadedregions.TickRegions;
+import me.earthme.molia.thread.CraftSchedulerRunner;
 import net.minecraft.core.BlockPos;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ServerLevel;
@@ -18,6 +19,8 @@ import net.minecraft.world.level.Level;
 import net.minecraft.world.phys.AABB;
 import net.minecraft.world.phys.Vec3;
 import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.scheduler.CraftScheduler;
+
 import java.util.concurrent.atomic.AtomicInteger;
 
 public class TickThread extends Thread {
@@ -131,18 +134,34 @@ public class TickThread extends Thread {
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final BlockPos pos) {
+        if (CraftSchedulerRunner.isRunnerThread()){
+            return true;
+        }
+
         return isTickThreadFor(world, pos.getX() >> 4, pos.getZ() >> 4);
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final ChunkPos pos) {
+        if (CraftSchedulerRunner.isRunnerThread()){
+            return true;
+        }
+
         return isTickThreadFor(world, pos.x, pos.z);
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final Vec3 pos) {
+        if (CraftSchedulerRunner.isRunnerThread()){
+            return true;
+        }
+
         return isTickThreadFor(world, Mth.floor(pos.x) >> 4, Mth.floor(pos.z) >> 4);
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final int chunkX, final int chunkZ) {
+        if (CraftSchedulerRunner.isRunnerThread()){
+            return true;
+        }
+
         final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
             TickRegionScheduler.getCurrentRegion();
         if (region == null) {
@@ -152,6 +171,10 @@ public class TickThread extends Thread {
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final AABB aabb) {
+        if (CraftSchedulerRunner.isRunnerThread()){
+            return true;
+        }
+
         return isTickThreadFor(
             world,
             CoordinateUtils.getChunkCoordinate(aabb.minX), CoordinateUtils.getChunkCoordinate(aabb.minZ),
@@ -160,10 +183,17 @@ public class TickThread extends Thread {
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final double blockX, final double blockZ) {
+        if (CraftSchedulerRunner.isRunnerThread()){
+            return true;
+        }
         return isTickThreadFor(world, CoordinateUtils.getChunkCoordinate(blockX), CoordinateUtils.getChunkCoordinate(blockZ));
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final Vec3 position, final Vec3 deltaMovement, final int buffer) {
+        if (CraftSchedulerRunner.isRunnerThread()){
+            return true;
+        }
+
         final int fromChunkX = CoordinateUtils.getChunkX(position);
         final int fromChunkZ = CoordinateUtils.getChunkZ(position);
 
@@ -181,6 +211,10 @@ public class TickThread extends Thread {
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final int fromChunkX, final int fromChunkZ, final int toChunkX, final int toChunkZ) {
+        if (CraftSchedulerRunner.isRunnerThread()){
+            return true;
+        }
+
         final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
             TickRegionScheduler.getCurrentRegion();
         if (region == null) {
@@ -208,10 +242,18 @@ public class TickThread extends Thread {
     }
 
     public static boolean isTickThreadFor(final ServerLevel world, final int chunkX, final int chunkZ, final int radius) {
+        if (CraftSchedulerRunner.isRunnerThread()){
+            return true;
+        }
+        
         return isTickThreadFor(world, chunkX - radius, chunkZ - radius, chunkX + radius, chunkZ + radius);
     }
 
     public static boolean isTickThreadFor(final Entity entity) {
+        if (CraftSchedulerRunner.isRunnerThread()){
+            return true;
+        }
+
         if (entity == null) {
             return true;
         }
diff --git a/src/main/java/me/earthme/molia/thread/CraftSchedulerRunner.java b/src/main/java/me/earthme/molia/thread/CraftSchedulerRunner.java
index 6bc03b13b0a62e7e7b06fbd2ea181c309b7a4365..d9259bdbcf8f458e3612168f6f613f5d8ba92bb9 100644
--- a/src/main/java/me/earthme/molia/thread/CraftSchedulerRunner.java
+++ b/src/main/java/me/earthme/molia/thread/CraftSchedulerRunner.java
@@ -35,6 +35,7 @@ public class CraftSchedulerRunner extends TickThread implements Executor {
         RUNNER_INSTANCE.setName("Craft Scheduler Runner Thread");
         RUNNER_INSTANCE.setPriority(3);
         RUNNER_INSTANCE.setDaemon(true);
+        RUNNER_INSTANCE.start();
     }
 
     public static boolean isRunnerThread(){
