From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: wangxyper <wangxyper@163.com>
Date: Mon, 28 Aug 2023 08:51:39 +0800
Subject: [PATCH] Fix async issue


diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java
index 1dd3afb9c204a9f28610b43af398103e0c989113..dabdfb4143cf04da7cda03e39d9904e457f171a7 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java
@@ -5,6 +5,7 @@ import ca.spottedleaf.concurrentutil.scheduler.SchedulerThreadPool;
 import com.mojang.logging.LogUtils;
 import io.papermc.paper.threadedregions.scheduler.FoliaGlobalRegionScheduler;
 import io.papermc.paper.util.TickThread;
+import me.earthme.molia.thread.CraftSchedulerRunner;
 import net.minecraft.CrashReport;
 import net.minecraft.ReportedException;
 import net.minecraft.network.Connection;
@@ -99,8 +100,8 @@ public final class RegionizedServer {
 
     public static boolean isGlobalTickThread() {
         //DirtyMolia start - Drop global region check
-        //return INSTANCE.tickHandle == TickRegionScheduler.getCurrentTickingTask();
-        return true;
+        return INSTANCE.tickHandle == TickRegionScheduler.getCurrentTickingTask() || CraftSchedulerRunner.isRunnerThread();
+        //return true;
         //Molia end
     }
 
diff --git a/src/main/java/io/papermc/paper/util/TickThread.java b/src/main/java/io/papermc/paper/util/TickThread.java
index 8378da3fc4b477b980caa78f98ad916522eb161d..35d356163ded2bac903dd4dd7c9b7e79f7731d69 100644
--- a/src/main/java/io/papermc/paper/util/TickThread.java
+++ b/src/main/java/io/papermc/paper/util/TickThread.java
@@ -50,50 +50,50 @@ public class TickThread extends Thread {
     @Deprecated
     public static void ensureTickThread(final String reason) {
         if (!isTickThread()) {
-            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            //throw new IllegalStateException(reason);
+            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final BlockPos pos, final String reason) {
         if (!isTickThreadFor(world, pos)) {
-            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            //throw new IllegalStateException(reason);
+            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final ChunkPos pos, final String reason) {
         if (!isTickThreadFor(world, pos)) {
-            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            //throw new IllegalStateException(reason);
+            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final int chunkX, final int chunkZ, final String reason) {
         if (!isTickThreadFor(world, chunkX, chunkZ)) {
-            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            //throw new IllegalStateException(reason);
+            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final Entity entity, final String reason) {
         if (!isTickThreadFor(entity)) {
-            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            //throw new IllegalStateException(reason);
+            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final AABB aabb, final String reason) {
         if (!isTickThreadFor(world, aabb)) {
-            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            //throw new IllegalStateException(reason);
+            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            throw new IllegalStateException(reason);
         }
     }
 
     public static void ensureTickThread(final ServerLevel world, final double blockX, final double blockZ, final String reason) {
         if (!isTickThreadFor(world, blockX, blockZ)) {
-            //MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
-            //throw new IllegalStateException(reason);
+            MinecraftServer.LOGGER.error("Thread " + Thread.currentThread().getName() + " failed main thread check: " + reason, new Throwable());
+            throw new IllegalStateException(reason);
         }
     }
 
