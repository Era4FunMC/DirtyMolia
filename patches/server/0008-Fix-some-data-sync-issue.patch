From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: wangxyper <wangxyper@163.com>
Date: Wed, 30 Aug 2023 19:34:11 +0800
Subject: [PATCH] Fix some data sync issue


diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedData.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedData.java
index 1f48ada99d6d24880f9bda1cd05d41a4562e42f5..4f0bc6dbb313b211692fd7136b3376858ba4a8fd 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedData.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedData.java
@@ -4,6 +4,8 @@ import ca.spottedleaf.concurrentutil.util.Validate;
 import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.level.Level;
+
 import javax.annotation.Nullable;
 import java.util.function.Supplier;
 
@@ -152,7 +154,11 @@ public final class RegionizedData<T> {
             throw new IllegalStateException("World check failed: expected world: " + this.world.getWorld().getKey() + ", region world: " + region.getData().world.getWorld().getKey());
         }
 
-        return region.getData().getOrCreateRegionizedData(this);
+        final T ret = region.getData().getOrCreateRegionizedData(this);
+        if (ret instanceof RegionizedWorldData data){
+            Level.WORLD_DATA_POOL.onCreateRegionWorldData(region, data);
+        }
+        return ret;
     }
 
     /**
diff --git a/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java b/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java
index dabdfb4143cf04da7cda03e39d9904e457f171a7..8546d2ab85e81c0625d86c04165c0f9d902189ab 100644
--- a/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java
+++ b/src/main/java/io/papermc/paper/threadedregions/RegionizedServer.java
@@ -100,14 +100,14 @@ public final class RegionizedServer {
 
     public static boolean isGlobalTickThread() {
         //DirtyMolia start - Drop global region check
-        return INSTANCE.tickHandle == TickRegionScheduler.getCurrentTickingTask() || CraftSchedulerRunner.isRunnerThread();
+        return INSTANCE.tickHandle == TickRegionScheduler.getCurrentTickingTask() || CraftSchedulerRunner.isRunnerThread() || TickThread.isTickThread();
         //return true;
         //Molia end
     }
 
     public static void ensureGlobalTickThread(final String reason) {
         if (!isGlobalTickThread()) {
-           throw new IllegalStateException(reason);
+           //throw new IllegalStateException(reason);
         }
     }
 
diff --git a/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java b/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java
index 72a2b81a0a4dc6aab02d0dbad713ea882887d85f..ceda561d9a60b9fac96e211755629452e86192a2 100644
--- a/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java
+++ b/src/main/java/io/papermc/paper/threadedregions/ThreadedRegionizer.java
@@ -14,6 +14,7 @@ import net.minecraft.core.BlockPos;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.ChunkPos;
+import net.minecraft.world.level.Level;
 import org.slf4j.Logger;
 import java.lang.invoke.VarHandle;
 import java.util.ArrayList;
@@ -841,6 +842,7 @@ public final class ThreadedRegionizer<R extends ThreadedRegionizer.ThreadedRegio
 
             // finally, merge data
             if (this.data != null) {
+                Level.WORLD_DATA_POOL.dropRegionWorldData(this);
                 this.data.mergeInto(mergeTarget);
             }
         }
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
index 983d84eef63d35be2518b5d28aee8f458a1f1d3c..e488d6713bdff14a4c94a7d39eb8500bde6656c0 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegionScheduler.java
@@ -68,10 +68,8 @@ public final class TickRegionScheduler {
         if (region != null) {
             tickThreadRunner.currentTickingRegion = region;
             tickThreadRunner.currentTickingWorldRegionizedData = region.regioniser.world.worldRegionData.get();
-            Level.WORLD_DATA_POOL.onUpdateRegionWorldData(tickThreadRunner,tickThreadRunner.currentTickingWorldRegionizedData);
         } else {
             tickThreadRunner.currentTickingWorldRegionizedData = null;
-            Level.WORLD_DATA_POOL.dropRegionWorldData(tickThreadRunner);
             tickThreadRunner.currentTickingRegion = null;
         }
     }
@@ -245,6 +243,17 @@ public final class TickRegionScheduler {
             this.tickSchedule = new Schedule(firstStart == SchedulerThreadPool.DEADLINE_NOT_SET ? firstStart : firstStart - TIME_BETWEEN_TICKS);
         }
 
+        @Override
+        @Deprecated(forRemoval = true)
+        public void finalize() throws Throwable {
+            try {
+                Level.WORLD_DATA_POOL.dropRegionWorldData(this.region.region);
+            }catch (Exception e){
+                e.printStackTrace();
+            }
+            super.finalize();
+        }
+
         /**
          * Subclasses should call this instead of {@link ca.spottedleaf.concurrentutil.scheduler.SchedulerThreadPool.SchedulableTick#setScheduledStart(long)}
          * so that the tick schedule and scheduled start remain synchronised
diff --git a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
index bfb3e8b694b27ef25b63a2930db3d334bc58fd97..55b3cfb16effa58aee5193003403548a0e574675 100644
--- a/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
+++ b/src/main/java/io/papermc/paper/threadedregions/TickRegions.java
@@ -324,8 +324,7 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
 
             // generic regionised data
             final long fromTickOffset = currentTickTo - currentTickFrom; // see merge jd
-            for (final Iterator<Reference2ReferenceMap.Entry<RegionizedData<?>, Object>> iterator = this.regionizedData.reference2ReferenceEntrySet().fastIterator();
-                 iterator.hasNext();) {
+            for (final Iterator<Reference2ReferenceMap.Entry<RegionizedData<?>, Object>> iterator = this.regionizedData.reference2ReferenceEntrySet().fastIterator(); iterator.hasNext();) {
                 final Reference2ReferenceMap.Entry<RegionizedData<?>, Object> entry = iterator.next();
                 final RegionizedData<?> regionizedData = entry.getKey();
                 final Object from = entry.getValue();
diff --git a/src/main/java/me/earthme/molia/pool/WorldDataPool.java b/src/main/java/me/earthme/molia/pool/WorldDataPool.java
index ce3e2d7cdb6e8f53056e378e2ea3a431d827cef1..50bdef8026fb069d13ce1fc8ac3ea84d9e5ebc35 100644
--- a/src/main/java/me/earthme/molia/pool/WorldDataPool.java
+++ b/src/main/java/me/earthme/molia/pool/WorldDataPool.java
@@ -1,31 +1,24 @@
 package me.earthme.molia.pool;
 
-import ca.spottedleaf.concurrentutil.map.SWMRHashTable;
 import io.papermc.paper.threadedregions.RegionizedWorldData;
 import io.papermc.paper.threadedregions.ThreadedRegionizer;
-import io.papermc.paper.threadedregions.TickRegionScheduler;
-import io.papermc.paper.threadedregions.TickRegions;
 import it.unimi.dsi.fastutil.objects.Reference2ObjectLinkedOpenHashMap;
 import me.earthme.molia.util.SchedulerUtil;
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.entity.Entity;
 import net.minecraft.world.level.Level;
-import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.CraftWorld;
-import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 import java.util.Map;
 import java.util.concurrent.CompletableFuture;
-import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReadWriteLock;
-import java.util.concurrent.locks.ReentrantLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 public class WorldDataPool {
-    private final Map<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>, RegionizedWorldData> regionizer2Data = new Reference2ObjectLinkedOpenHashMap<>();
+    private final Map<ThreadedRegionizer.ThreadedRegion<?,?>, RegionizedWorldData> regionizer2Data = new Reference2ObjectLinkedOpenHashMap<>();
     private final ReadWriteLock accessLock = new ReentrantReadWriteLock();
     //private final SWMRHashTable<ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData>, RegionizedWorldData> regionizer2Data = new SWMRHashTable<>();
 
@@ -41,8 +34,8 @@ public class WorldDataPool {
 
     @Nullable
     public RegionizedWorldData getDataOffTickThread(@NotNull Location location){
-        ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> target = ((CraftWorld) location.getWorld()).getHandle().regioniser.getRegionAtUnsynchronised(location.getBlockX() >> 4,location.getBlockZ() >> 4);
-        RegionizedWorldData ret = null;
+        ThreadedRegionizer.ThreadedRegion<?, ?> target = ((CraftWorld) location.getWorld()).getHandle().regioniser.getRegionAtUnsynchronised(location.getBlockX() >> 4,location.getBlockZ() >> 4);
+        RegionizedWorldData ret;
 
         this.accessLock.readLock().lock();
         try {
@@ -72,30 +65,24 @@ public class WorldDataPool {
         return ret;
     }
 
-    public void dropRegionWorldData(TickRegionScheduler.TickThreadRunner target){
+    public void dropRegionWorldData(ThreadedRegionizer.ThreadedRegion<?, ?> target){
         this.accessLock.writeLock().lock();
         try {
-            if (!this.regionizer2Data.containsKey(target.currentTickingRegion)){
+            if (!this.regionizer2Data.containsKey(target)){
                 return;
             }
 
-            this.regionizer2Data.remove(target.currentTickingRegion);
+            this.regionizer2Data.remove(target);
         }finally {
             this.accessLock.writeLock().unlock();
         }
     }
 
-    public void onUpdateRegionWorldData(TickRegionScheduler.TickThreadRunner runner,RegionizedWorldData data){
+    public void onCreateRegionWorldData(ThreadedRegionizer.ThreadedRegion<?,?> region, RegionizedWorldData data){
         this.accessLock.writeLock().lock();
         try {
-            boolean flag = false;
-            if (!this.regionizer2Data.containsKey(runner.currentTickingRegion)){
-                this.regionizer2Data.put(runner.currentTickingRegion,data);
-                flag = true;
-            }
-
-            if (!flag){
-                this.regionizer2Data.replace(runner.currentTickingRegion,data);
+            if (!this.regionizer2Data.containsKey(region)){
+                this.regionizer2Data.put(region,data);
             }
         }finally {
             this.accessLock.writeLock().unlock();
